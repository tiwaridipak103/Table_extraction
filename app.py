{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "JZVCCZ48AH5j"
   },
   "outputs": [],
   "source": [
    "from io import StringIO\n",
    "import os\n",
    "import tensorflow as tf\n",
    "import keras\n",
    "import cv2\n",
    "\n",
    "from PIL import Image\n",
    "import pytesseract\n",
    "\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "try:\n",
    "    from PIL import Image\n",
    "except ImportError:\n",
    "    import Image\n",
    "import pytesseract\n",
    "\n",
    "pytesseract.pytesseract.tesseract_cmd = r\"C:\\Program Files\\Tesseract-OCR\\tesseract.exe\"\n",
    "\n",
    "from flask import Flask, render_template, request,jsonify,Response\n",
    "\n",
    "from keras.models import load_model\n",
    "model = load_model('mymodel_196')\n",
    "\n",
    "\n",
    "UPLOAD_FOLDER = 'uploads/'\n",
    "app = Flask(__name__)\n",
    "app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n",
    "\n",
    "\n",
    "\n",
    "def masks(table_mask, column_mask):\n",
    "  table_mask = np.argmax(table_mask, axis=-1)\n",
    "  table_mask = table_mask[..., np.newaxis]\n",
    "\n",
    "\n",
    "  column_mask = np.argmax(column_mask, axis=-1)\n",
    "  column_mask = column_mask[..., np.newaxis]\n",
    "  return table_mask[0], column_mask[0]\n",
    "\n",
    "\n",
    "def sort_contours(cnts, method=\"left-to-right\"):\n",
    "    # initialize the reverse flag and sort index\n",
    "    reverse = False\n",
    "    i = 0\n",
    "    # handle if we need to sort in reverse\n",
    "    if method == \"right-to-left\" or method == \"bottom-to-top\":\n",
    "        reverse = True\n",
    "        # handle if we are sorting against the y-coordinate rather than\n",
    "        # the x-coordinate of the bounding box\n",
    "    if method == \"top-to-bottom\" or method == \"bottom-to-top\":\n",
    "        i = 1\n",
    "        # construct the list of bounding boxes and sort them from top to\n",
    "        # bottom\n",
    "    boundingBoxes = [cv2.boundingRect(c) for c in cnts]\n",
    "    (cnts, boundingBoxes) = zip(*sorted(zip(cnts, boundingBoxes),\n",
    "    key=lambda b:b[1][i], reverse=reverse))\n",
    "    # return the list of sorted contours and bounding boxes\n",
    "    return (cnts, boundingBoxes)\n",
    "\n",
    "#creating function to input image path and in return we get text file \n",
    "def ocr_tesseract(img):\n",
    "    text = pytesseract.image_to_string(img)  \n",
    "    return text\n",
    "def table_csv(file_):\n",
    "    #read your file\n",
    "    file = file_\n",
    "    img = cv2.imread(file,0)\n",
    "    thresh,img_bin = cv2.threshold(img,128,255,cv2.THRESH_OTSU)\n",
    "    img_bin = 255-img_bin\n",
    "    \n",
    "    # Length(width) of kernel as 100th of total width\n",
    "    kernel_len = np.array(img).shape[1]//100\n",
    "\n",
    "    # Defining a vertical kernel to detect all vertical lines of image \n",
    "    ver_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, kernel_len))\n",
    "\n",
    "    # Defining a horizontal kernel to detect all horizontal lines of image\n",
    "    hor_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (kernel_len, 1))\n",
    "\n",
    "    # A kernel of 2x2\n",
    "    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 2))\n",
    "\n",
    "    #Use vertical kernel to detect and save the vertical lines in a jpg\n",
    "    image_1 = cv2.erode(img_bin, ver_kernel, iterations=3)\n",
    "    vertical_lines = cv2.dilate(image_1, ver_kernel, iterations=3)\n",
    "    \n",
    "    #Use horizontal kernel to detect and save the horizontal lines in a jpg\n",
    "    image_2 = cv2.erode(img_bin, hor_kernel, iterations=3)\n",
    "    horizontal_lines = cv2.dilate(image_2, hor_kernel, iterations=3)\n",
    "    \n",
    "    img_vh = cv2.addWeighted(vertical_lines, 0.5, horizontal_lines, 0.5, 0.0)\n",
    "    #Eroding and thesholding the image\n",
    "    img_vh = cv2.erode(~img_vh, kernel, iterations=2)\n",
    "\n",
    "    x=np.ones([1024,1024])\n",
    "    k= img_vh * x\n",
    "    for i in range(1024):\n",
    "        for j in range(1024):\n",
    "            if k[i][j] != 255:\n",
    "                #k[i][j][0] =  np.array([225,225,225]) \n",
    "                a = k[i][j]\n",
    "                k[i][j] =  a - 255\n",
    "    \n",
    "    im=keras.preprocessing.image.array_to_img(k[:,:,np.newaxis])\n",
    "    im.save('new.bmp')\n",
    "    \n",
    "    fi=r'new.bmp'\n",
    "    imgk = cv2.imread(fi,0)\n",
    "\n",
    "    thresh, img_vh_ = cv2.threshold(img_vh,128,255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)\n",
    "    \n",
    "    bitxor = cv2.bitwise_xor(img,img_vh)\n",
    "    bitnot = cv2.bitwise_not(bitxor)\n",
    "    \n",
    "    # Detect contours for following box detection\n",
    "    contours, hierarchy = cv2.findContours(img_vh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n",
    "    \n",
    "    # Sort all the contours by top to bottom.\n",
    "    contours, boundingBoxes = sort_contours(contours, method=\"top-to-bottom\")\n",
    "    \n",
    "    #Creating a list of heights for all detected boxes\n",
    "    heights = [boundingBoxes[i][3] for i in range(len(boundingBoxes))]\n",
    "    #Get mean of heights\n",
    "    mean = np.mean(heights)\n",
    "    \n",
    "    #Create list box to store all boxes in  \n",
    "    box = []\n",
    "    # Get position (x,y), width and height for every contour and show the contour on image\n",
    "    for c in contours:\n",
    "        x, y, w, h = cv2.boundingRect(c)\n",
    "        if (w<1000 and h<500):\n",
    "            image = cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2)\n",
    "            box.append([x,y,w,h])\n",
    "            \n",
    "    x = list(sorted(set([i[0] for i in box])))\n",
    "    y = list(sorted(set([i[1] for i in box])))\n",
    "\n",
    "    if len(x) != 0 and len(y) != 0:\n",
    "      j = 0\n",
    "      collect = []\n",
    "      for k in x:\n",
    "          if j == 0:\n",
    "              j = k\n",
    "          else:\n",
    "              collect.append(k - j)\n",
    "              j = k\n",
    "          \n",
    "          \n",
    "      x_collect = []\n",
    "      for i in range(2):\n",
    "          if i == 0:\n",
    "              if int(np.mean(collect)*2) <= x[i]:\n",
    "                  x_collect.append(x[i]-int(np.mean(collect)*2))\n",
    "              else:\n",
    "                  x_collect.append(0)\n",
    "              \n",
    "          else:\n",
    "              if int(np.mean(collect)*2) <= 1024-x[len(x)-1]:\n",
    "                  x_collect.append(x[len(x)-1]+int(np.mean(collect)*2))\n",
    "              else:\n",
    "                  x_collect.append(1024)\n",
    "      x.extend(x_collect)  \n",
    "\n",
    "      x = sorted(x)   \n",
    "      \n",
    "      y = list(sorted(set([i[1] for i in box])))\n",
    "\n",
    "      j = 0\n",
    "      collect_y = []\n",
    "      for k in y:\n",
    "          if j == 0:\n",
    "              j = k\n",
    "          else:\n",
    "              collect_y.append(k - j)\n",
    "              j = k\n",
    "          \n",
    "      y_collect = []\n",
    "      for i in range(2):\n",
    "          if i == 0:\n",
    "              if int(np.median(collect_y)*2) <= y[i]:\n",
    "                  y_collect.append(y[i]-int(np.median(collect_y)*2))\n",
    "              else: \n",
    "                  y_collect.append(0)\n",
    "          else:\n",
    "              if int(np.median(collect_y)*2) <= 1024-y[len(y)-1]:\n",
    "                  y_collect.append(y[len(y)-1]+int(np.median(collect_y)*2))\n",
    "              else:\n",
    "                  y_collect.append(10240)\n",
    "\n",
    "      y.extend(y_collect)   \n",
    "\n",
    "      y = sorted(y)\n",
    "      \n",
    "      li = []\n",
    "      img1=Image.open(file)\n",
    "      for i , m in enumerate(y):\n",
    "          if i +1 != len(y):\n",
    "              string = []\n",
    "              for j , n in enumerate(x):\n",
    "                  if j +1 != len(x):\n",
    "                      #print('yes')\n",
    "                      x_min = n\n",
    "                      y_min = m\n",
    "                      x_max = x[j+1]\n",
    "                      y_max = y[i+1]\n",
    "                      \n",
    "                      crop = (x_min,y_min,x_max,y_max)\n",
    "                      cropped_table_ = img1.crop(crop)\n",
    "                      text = ocr_tesseract(cropped_table_)\n",
    "                      w = []\n",
    "                      for word in text.split(\"\\n\"):\n",
    "                          if word != '\\x0c':\n",
    "                              w.append(str(word))\n",
    "\n",
    "                      if len(w):\n",
    "                          wo = ' '.join(w) \n",
    "                      else:\n",
    "                          w.append(' ')\n",
    "                      wo = ' '.join(w)\n",
    "                      #words = filter_word()\n",
    "                      words = wo\n",
    "                      string.append(words)\n",
    "                      #print(words)\n",
    "              li.append(string) \n",
    "\n",
    "      # name of csv file \n",
    "      filename = \"records.csv\"\n",
    "      \n",
    "      # writing to csv file \n",
    "      with open(filename, 'w') as csvfile:\n",
    "          csvwriter = csv.writer(csvfile) \n",
    "          csvwriter.writerows(li)\n",
    "          \n",
    "      data = pd.read_csv('records.csv',encoding= 'unicode_escape')    \n",
    "      \n",
    "      return data\n",
    "    else:\n",
    "      return None  \n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "def ocr_tesseracts_(filename):\n",
    "    text = pytesseract.image_to_string(Image.open(filename))  \n",
    "    return text\n",
    "\n",
    "\n",
    "\n",
    "@app.route('/')\n",
    "def hello_world():\n",
    "    return render_template('new_upload.html')\n",
    "    #return 'To access the webpage please visit \"upload\" page'\n",
    "\n",
    "\n",
    "@app.route('/uploader', methods=['POST'])\n",
    "def upload_file():\n",
    "    f = request.files['file']\n",
    "    name=f.filename\n",
    "\n",
    "    f.save(os.path.join(app.config['UPLOAD_FOLDER'], name))\n",
    "    new_path = os.path.join(app.config['UPLOAD_FOLDER'], name)\n",
    "\n",
    "    #reading  , resizing and normalizing for image data\n",
    "    images1 = tf.io.read_file(new_path)\n",
    "    images1 = tf.image.decode_jpeg(images1, channels=3)\n",
    "    images1 = tf.image.resize(images1, [1024, 1024])  #Decode a JPEG-encoded image to a uint8 tensor\n",
    "    images1 = tf.cast(images1, tf.float32) / 255.0 # normalizing image\n",
    "\n",
    "\n",
    "    mask1, mask2 = model.predict(images1[np.newaxis,:,:,:])\n",
    "    table_mask, column_mask = masks(mask1, mask2)\n",
    "\n",
    "    images3=keras.preprocessing.image.array_to_img(images1)\n",
    "    images3.save('images3.png')\n",
    "        \n",
    "    table_mask  = keras.preprocessing.image.array_to_img(table_mask)\n",
    "    table_mask.save('table_mask.bmp')\n",
    "        \n",
    "    column_mask = keras.preprocessing.image.array_to_img(column_mask)\n",
    "\n",
    "    # convert images\n",
    "    #table_mask = table_mask.convert('L')    # grayscale\n",
    "\n",
    "\n",
    "    # add alpha channel    \n",
    "    #images1.putalpha(table_mask)\n",
    "\n",
    "\n",
    "    # save as png which keeps alpha channel \n",
    "    images1.save('output.png')\n",
    "\n",
    "    #importing file\n",
    "    images2 = cv2.imread('output.png',cv2.IMREAD_UNCHANGED)\n",
    "\n",
    "\n",
    "    img = mpimg.imread('images3.bmp')\n",
    "    img_table = mpimg.imread('table_mask.bmp')\n",
    "\n",
    "    x=np.ones([1024,1024 , 3])\n",
    "    k= img * x\n",
    "    for i in range(1024):\n",
    "      for j in range(1024):\n",
    "        if img_table[i][j] == 0:\n",
    "          k[i][j] =  np.array([0,0,0])\n",
    "\n",
    "    for i in range(1024):\n",
    "      for j in range(1024):\n",
    "        if k[i][j][0] == 0:\n",
    "          k[i][j][0] =  np.array([225,225,225]) \n",
    "          k[i][j][0] =  255   \n",
    "\n",
    "    for i in range(1024):\n",
    "      for j in range(1024):\n",
    "        if k[i][j][0] != 255:\n",
    "          k[i][j][0] =  np.array([225,225,225]) \n",
    "          a = k[i][j][0]\n",
    "          k[i][j][0] =  a - 255\n",
    "\n",
    "    images4=tf.keras.preprocessing.image.array_to_img(k)\n",
    "    images4.save('test.png')  \n",
    " \n",
    "\n",
    "    os.remove(os.path.join(app.config['UPLOAD_FOLDER'], name)) \n",
    "\n",
    "    data1 = table_csv('test.png')\n",
    "    if data1 is None:\n",
    "      return Response(render_template('result.html',data=['there is no table available for this image'])\n",
    "\n",
    "    else:\n",
    "      df_list = data1.values.tolist()\n",
    "\n",
    "      output = StringIO()\n",
    "      data1.to_csv(output)\n",
    "\n",
    "      return Response(data1.to_csv(),mimetype=\"text/csv\",headers={\"Content-disposition\":\"attachment; filename=filename.csv\"})\n",
    "\n",
    "\n",
    "\t\t\n",
    "if __name__ == '__main__':\n",
    "   app.run(host='0.0.0.0',debug=True, port=5050)"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [],
   "name": "app.ipynb",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
